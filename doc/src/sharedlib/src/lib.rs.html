<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `src\lib.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>lib.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
</pre><pre class='rust '>
<span class='doccomment'>//! A simple cross-platform library loader.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ([crates.io](https://crates.io/crates/sharedlib)) ([github](https://github.com/Tyleo/sharedlib))</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! Based on [libloading](https://crates.io/crates/libloading) by Simonas Kazlauskas.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Loading a library</span>
<span class='doccomment'>//! To load a library you can use any of the [Lib](struct.Lib.html), [LibTracked](struct.LibTracked.html), or [LibUnsafe](struct.LibUnsafe.html) `structs`. Each of these `struct`s provides different guarantees. For more information about the guarantees they provide, see the [chosing your guarantees](index.html#choosing-your-guarantees) section, below. We use [Lib](struct.Lib.html) for the examples below.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### Calling a function in another library</span>
<span class='doccomment'>//! ``` no_run</span>
<span class='doccomment'>//! # use sharedlib::Func;</span>
<span class='doccomment'>//! # use sharedlib::Lib;</span>
<span class='doccomment'>//! # use sharedlib::SharedlibResult as R;</span>
<span class='doccomment'>//! # use sharedlib::Symbol;</span>
<span class='doccomment'>//! # fn test() -&gt; R&lt;()&gt; {</span>
<span class='doccomment'>//! unsafe {</span>
<span class='doccomment'>//!     let path_to_lib = &quot;examplelib.dll&quot;;</span>
<span class='doccomment'>//!     let lib = try!(Lib::new(path_to_lib));</span>
<span class='doccomment'>//!     let hello_world_symbol: Func&lt;extern &quot;C&quot; fn()&gt; = try!(lib.find_func(&quot;hello_world&quot;));</span>
<span class='doccomment'>//!     let hello_world = hello_world_symbol.get();</span>
<span class='doccomment'>//!     hello_world();</span>
<span class='doccomment'>//! }</span>
<span class='doccomment'>//! # Ok(())</span>
<span class='doccomment'>//! # }</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### Accessing data in another library</span>
<span class='doccomment'>//! ``` no_run</span>
<span class='doccomment'>//! # use sharedlib::Data;</span>
<span class='doccomment'>//! # use sharedlib::Lib;</span>
<span class='doccomment'>//! # use sharedlib::SharedlibResult as R;</span>
<span class='doccomment'>//! # use sharedlib::Symbol;</span>
<span class='doccomment'>//! # fn test() -&gt; R&lt;()&gt; {</span>
<span class='doccomment'>//! unsafe {</span>
<span class='doccomment'>//!     let path_to_lib = &quot;examplelib.dll&quot;;</span>
<span class='doccomment'>//!     let lib = try!(Lib::new(path_to_lib));</span>
<span class='doccomment'>//!     let my_usize_symbol: Data&lt;usize&gt; = try!(lib.find_data(&quot;my_usize&quot;));</span>
<span class='doccomment'>//!     let my_usize = my_usize_symbol.get();</span>
<span class='doccomment'>//!     assert_eq!(*my_usize, 0);</span>
<span class='doccomment'>//! }</span>
<span class='doccomment'>//! # Ok(())</span>
<span class='doccomment'>//! # }</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### Choosing your guarantees</span>
<span class='doccomment'>//! A common problem when loading a shared library at runtime is that a symbol may be accessed after its library has been unloaded. [sharedlib](index.html) attempts to prevent this by allowing the lifetime of the library to be tracked. Each of the different libraries, [Lib](struct.Lib.html), [LibTracked](struct.LibTracked.html), or [LibUnsafe](struct.LibUnsafe.html), provides a different tracking mechanism. Below is a small overview. For more information, see the struct level documentation.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! * [LibUnsafe](struct.LibUnsafe.html) does not provide any tracking at all. This requires no overhead but responsibility falls on the client to be sure that the library is still alive when its symbols are used.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! * [Lib](struct.Lib.html) attaches its own lifetime to each symbol it returns. This requires no overhead but it can be difficult to store the returned symbol in a `struct` because the `struct` must have a trackable lifetime which outlives the [Lib](struct.Lib.html). In other words, a struct containing a symbol must parameterize around some lifetime `a`, where `a` is less than or equal to the lifetime of the library.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! * [LibTracked](struct.LibTracked.html) returns symbols with ref-counts to the library. This requires overhead but it allows the returned symbol to be stored easily. Additionally, this `struct` is generic and can be used with `Rc`, `Arc`, or a user provided ref-count type.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Pitfalls</span>
<span class='doccomment'>//! While [sharedlib](index.html) attempts to prevent undefined behavior, loading shared libraries is inherently unsafe. Below are some tips which you may find helpful so that your code is not exposed to undefined behavior.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### Avoid copying or moving data returned from `get()`</span>
<span class='doccomment'>//! The [get](trait.Symbol.html#method.get) method on [Symbol](trait.Symbol.html) returns a transmuted pointer to something in a loaded library. While [sharedlib](index.html) tries to make sure that this pointer cannot outlive the library it is from, full protection is impossible. In particular: if a loaded `struct` contains pointers to things in the loaded library, and the loaded `struct` implements `Clone`, clients can clone the `struct` and make it to live longer than the library it is from. If this happens the pointers in the `struct` dangle. The example below demonstrate:</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ``` no_run</span>
<span class='doccomment'>//! # use sharedlib::Func;</span>
<span class='doccomment'>//! # use sharedlib::Lib;</span>
<span class='doccomment'>//! # use sharedlib::SharedlibResult as R;</span>
<span class='doccomment'>//! # use sharedlib::Symbol;</span>
<span class='doccomment'>//! # fn test() -&gt; R&lt;()&gt; {</span>
<span class='doccomment'>//! unsafe {</span>
<span class='doccomment'>//!     let some_func = {</span>
<span class='doccomment'>//!         let lib = try!(Lib::new(&quot;examplelib.dll&quot;));</span>
<span class='doccomment'>//!         let some_func_symbol: Func&lt;extern &quot;C&quot; fn()&gt; = try!(lib.find_func(&quot;some_func&quot;));</span>
<span class='doccomment'>//!         // All func pointers implement `Copy` so we can duplicate one.</span>
<span class='doccomment'>//!         some_func_symbol.get()</span>
<span class='doccomment'>//!         // lib goes out of scope here.</span>
<span class='doccomment'>//!     };</span>
<span class='doccomment'>//!     // Undefined behavior</span>
<span class='doccomment'>//!     some_func();</span>
<span class='doccomment'>//! }</span>
<span class='doccomment'>//! # Ok(())</span>
<span class='doccomment'>//! # }</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//! ### Use the correct method when getting functions or data</span>
<span class='doccomment'>//! Each library provides two different ways to get symbols from shared libraries. One way is `find_func`, and the other is `find_data`. Two functions are provded because `find_data` needs to return a reference to a `T` rather than a `T` itself, while `find_func` just needs to return a `T` itself. Returning the wrong thing can cause some complications. For instance: suppose we only have the `find_data` method, and we want to get a function pointer with the signature `fn()`. We are inclined to call `lib.find_data::&lt;fn()&gt;(b&quot;some_func&quot;)`. This searches the memory of the loaded binary and finds the address of the first line of the function `some_func`. Next, the *contents* of the first line of `some_func` are treated as a function pointer rather than the *address* of the first line of `some_func`. When the first line of `some_func` is returned it is incorrectly cast into a function pointer. Calling it produces undefined behavior. The example below demonstrates:</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ``` no_run</span>
<span class='doccomment'>//! # use sharedlib::Data;</span>
<span class='doccomment'>//! # use sharedlib::Lib;</span>
<span class='doccomment'>//! # use sharedlib::SharedlibResult as R;</span>
<span class='doccomment'>//! # use sharedlib::Symbol;</span>
<span class='doccomment'>//! # fn test() -&gt; R&lt;()&gt; {</span>
<span class='doccomment'>//! unsafe {</span>
<span class='doccomment'>//!     let lib = try!(Lib::new(&quot;examplelib.dll&quot;));</span>
<span class='doccomment'>//!     let some_func_symbol: Data&lt;extern &quot;C&quot; fn()&gt; = try!(lib.find_data(&quot;some_func&quot;));</span>
<span class='doccomment'>//!     // some_func actually points to a function but rust thinks it points to a function pointer.</span>
<span class='doccomment'>//!     let some_func = some_func_symbol.get();</span>
<span class='doccomment'>//!     // Undefined behavior</span>
<span class='doccomment'>//!     some_func();</span>
<span class='doccomment'>//! }</span>
<span class='doccomment'>//! # Ok(())</span>
<span class='doccomment'>//! # }</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! The correct way to do this with `find_data` is as follows:</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ``` no_run</span>
<span class='doccomment'>//! # use sharedlib::Data;</span>
<span class='doccomment'>//! # use sharedlib::Lib;</span>
<span class='doccomment'>//! # use sharedlib::SharedlibResult as R;</span>
<span class='doccomment'>//! # use sharedlib::Symbol;</span>
<span class='doccomment'>//! # fn test() -&gt; R&lt;()&gt; {</span>
<span class='doccomment'>//! unsafe {</span>
<span class='doccomment'>//!     let lib = try!(Lib::new(&quot;examplelib.dll&quot;));</span>
<span class='doccomment'>//!     // Get a pointer to the block of memory at &quot;some_func&quot;, this is the function itself.</span>
<span class='doccomment'>//!     let some_func_symbol: Data&lt;u8&gt; = try!(lib.find_data(&quot;some_func&quot;));</span>
<span class='doccomment'>//!     // The type of some_func is &amp;u8, a reference to the first byte of `some_func`. We can convert this into a function pointer.</span>
<span class='doccomment'>//!     let some_func = some_func_symbol.get();</span>
<span class='doccomment'>//!     let some_func_ptr: extern &quot;C&quot; fn() = std::mem::transmute(some_func);</span>
<span class='doccomment'>//!     // This works now.</span>
<span class='doccomment'>//!     some_func_ptr();</span>
<span class='doccomment'>//! }</span>
<span class='doccomment'>//! # Ok(())</span>
<span class='doccomment'>//! # }</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! For convienience, the second example is provided as the `find_func` method, which does this error-prone conversion behind the scenes.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Comparison with other crates for loabing shared libraries</span>
<span class='doccomment'>//! sharedlib was created out of frusteration with the existing crates for loading shared libraries. Below is a list of some of these crates with some information abuot how sharedlib improves upon them.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! * [dylib](https://crates.io/crates/dylib) provides an extremely simple interface for loading shared libraries. For awhile, this was the standard for loading shared libraries at runtime. Unfortunately, development on dylib has been mostly abandoned and it is no longer supported on the latest versions of the rust compiler.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! * [libloading](https://crates.io/crates/libloading) provides some additional safety guarantees on top of [dylib](https://crates.io/crates/dylib). [sharedlib](index.html) even started as a fork of [libloading](https://crates.io/crates/libloading). Unfortunately the interface [libloading](https://crates.io/crates/libloading) provides is extremely inflexible, requiring clients to transmute symbols so they can be used in `struct`s. Additionally, loading data does not work with this library which is a non-starter for many projects.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Frequently asked questions</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### What is a shared library?</span>
<span class='doccomment'>//! A shared library is a set of functions and variables which can be loaded after a program has been compiled. By loading a library after compilation, the library can be recompiled or changed without recompiling the main program. Shared libraries can even be loaded at runtime. Common shared library filetypes are *.dll* for windows, *.so* for unix, and *.dylib* for osx. For more information about what a shared library is, see [wikipedia](https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries).</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ### Doesn&#39;t rust already provide linking against shared libraries?</span>
<span class='doccomment'>//! While rust provides linking against shared libraries, it does not provide the ability to load them at runtime. If you only want to use shared libraries that you know about before runtime, you may find not find this crate very useful. On the other hand, if you wish to load something at runtime, like a plugin, you are in the right place.</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>define_error</span>;

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>lazy_static</span>;

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>windows</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>kernel32</span>;

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>windows</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>winapi</span>;

<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>error</span>;

<span class='kw'>mod</span> <span class='ident'>os</span>;

<span class='kw'>mod</span> <span class='ident'>lib_impl</span>;

<span class='kw'>mod</span> <span class='ident'>string</span>;

<span class='kw'>mod</span> <span class='ident'>symbol</span>;

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>test</span>;

<span class='kw'>mod</span> <span class='ident'>util</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>error</span>::<span class='ident'>SharedlibError</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>error</span>::<span class='ident'>SharedlibResult</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>lib_impl</span>::<span class='ident'>Lib</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>lib_impl</span>::<span class='ident'>LibArc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>lib_impl</span>::<span class='ident'>LibRc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>lib_impl</span>::<span class='ident'>LibTracked</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>lib_impl</span>::<span class='ident'>LibUnsafe</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>Data</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>DataArc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>DataRc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>DataTracked</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>DataUnsafe</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>Func</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>FuncArc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>FuncRc</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>FuncTracked</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>FuncUnsafe</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>symbol</span>::<span class='ident'>Symbol</span>;
</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "sharedlib";
        window.playgroundUrl = "";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    
    <script defer src="../../../search-index.js"></script>
</body>
</html>